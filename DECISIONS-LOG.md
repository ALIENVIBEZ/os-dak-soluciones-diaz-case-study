# üìù DECISIONS LOG: Adaptaci√≥n OS DAK en Soluciones D√≠az

**Registro de decisiones arquitect√≥nicas tomadas durante la adaptaci√≥n**

Este documento explica **QU√â decisiones se tomaron**, **POR QU√â**, y **ALTERNATIVAS rechazadas**.

---

## üéØ Contexto del Proyecto

```yaml
Aplicaci√≥n: Soluciones D√≠az CRM
Tipo: Sitio web p√∫blico + CRM construcci√≥n integrado
Stack: Next.js 14 (App Router) + Firebase
Usuarios: 4 roles (Guest, Cliente, Admin Mobile, Admin Desktop, SuperAdmin)
Complejidad: 52 URLs totales, multi-dispositivo, real-time
Developer: Patricio D√≠az (ADHD-I, Inteligencia Sist√©mica Top 5%)
Contexto: Necesidad de sistema recovery post-crash + arquitectura visualizable
```

---

## DECISI√ìN 1: CAPA 0 = Sistema de Roles (NO Guardian de Planes)

### ‚úÖ Decisi√≥n Tomada

```yaml
CAPA 0: Sistema de Roles (G/C/A/SA)

Implementaci√≥n:
  G  = Guest (no autenticado)
  C  = Cliente (autenticado)
  A  = Admin (Jonathan)
  SA = SuperAdmin (Patricio)

Funci√≥n:
  - Define qui√©n puede acceder a qu√© URLs
  - Roles determinan permisos en Firestore
  - Guardian real del sistema
```

### ü§î Razonamiento

**Por qu√© S√ç:**
1. **Es un sitio web CON CRM**
   - NO es solo herramienta interna
   - Tiene usuarios p√∫blicos (Guest) + autenticados (Cliente, Admin)
   - Roles son la base de toda la arquitectura

2. **Roles determinan TODO en el sistema:**
   - URLs accesibles (18 Guest, 26 Cliente, 46 Admin Mobile, 52 Admin Desktop)
   - Permisos en Firestore (Security Rules por rol)
   - Flujos de usuario (Guest ‚Üí Cliente requiere registro)
   - UI mostrada (componentes condicionales por rol)

3. **Guardian de Planes gen√©rico NO aplicaba:**
   - Template dice: "Valida planes ANTES de ejecutar"
   - En web p√∫blica, el "guardian" es el middleware que valida autenticaci√≥n
   - CAPA 0 como Roles es m√°s preciso al contexto real

**Por qu√© NO Guardian de Planes:**
- Template gen√©rico asume herramienta interna sin roles
- En Soluciones D√≠az, validar "planes" es secundario vs validar "qui√©n puede acceder"
- Roles son verificados en CADA request (middleware + Firestore Rules)

### ‚ùå Alternativa Rechazada

```yaml
Opci√≥n rechazada: CAPA 0 = Guardian de Planes (template original)

Por qu√© NO:
  - Template gen√©rico no encaja en sitio web p√∫blico
  - "Validar plan antes de ejecutar" es abstracto vs roles concretos
  - En producci√≥n, middleware valida ROL (no "plan")

Hubiera resultado en:
  - Documentaci√≥n desconectada de c√≥digo real
  - Confusi√≥n entre concepto abstracto vs implementaci√≥n
  - Claude Code sin mapeo directo a arquitectura
```

### üìä Resultado

**Impacto:**
- ‚úÖ Comunicaci√≥n 100% alineada con c√≥digo (`userRole === 'admin'`)
- ‚úÖ Documentaci√≥n refleja realidad (middleware, Firestore Rules)
- ‚úÖ F√°cil extensi√≥n futura (agregar rol `Vendedor` = agregar letra)

**Lecci√≥n aprendida:**
> **"CAPA 0 debe ser el guardian REAL del sistema, no el concepto gen√©rico del template."**

---

## DECISI√ìN 2: N√öMERO = Profundidad Funcional (NO F√≠sica)

### ‚úÖ Decisi√≥n Tomada

```yaml
N√öMERO = Profundidad FUNCIONAL (no niveles de URL)

Definici√≥n:
  1 = Puerta (selector, inicio)
  2 = T√∫nel (flujo guiado)
  3 = Control (dashboard, gesti√≥n)
  4 = Proyecci√≥n (analytics, futuro)

Ejemplos:
  1A: /cotizacion (1 nivel URL, pero es PUERTA)
  1B: /mi-dashboard (1 nivel URL, pero es DASHBOARD completo)
  2A1: /cotizacion/rapida (2 niveles URL, es T√öNEL)
```

### ü§î Razonamiento

**Por qu√© profundidad FUNCIONAL:**

1. **URLs no reflejan complejidad:**
   ```yaml
   /cotizacion (1 nivel) = Selector simple ‚Üí N√öMERO 1 ‚úÖ
   /mi-dashboard (1 nivel) = Dashboard completo con 4 tabs ‚Üí N√öMERO 1 ‚úÖ
   /admin/servicios (2 niveles) = CRUD completo ‚Üí N√öMERO 3 ‚úÖ
   ```

2. **Profundidad f√≠sica confunde:**
   ```yaml
   Si us√°ramos niveles f√≠sicos:
   /cotizacion = 1
   /mi-dashboard = 1
   /cotizacion/rapida = 2
   /admin/servicios = 2

   Problema: /mi-dashboard y /cotizacion tienen MISMO n√∫mero
   pero complejidad MUY diferente
   ```

3. **Funcional es predecible:**
   ```yaml
   1 = "¬øD√≥nde empieza usuario?" (puerta)
   2 = "¬øQu√© flujo sigue?" (t√∫nel)
   3 = "¬øD√≥nde gestiona?" (control)
   4 = "¬øQu√© analiza?" (proyecci√≥n)

   Mapeo mental m√°s claro que contar slashes en URL
   ```

### ‚ùå Alternativa Rechazada

```yaml
Opci√≥n rechazada: N√öMERO = Niveles de URL (/ = nivel)

Ejemplo si se hubiera usado:
  1: / (homepage)
  1: /cotizacion
  1: /mi-dashboard
  2: /cotizacion/rapida
  2: /admin/servicios
  3: /admin/servicios/create

Problemas:
  - /mi-dashboard (1) y /cotizacion (1) con misma profundidad
    pero /mi-dashboard es 10x m√°s complejo
  - Crear producto (/admin/servicios/create = 3) parece m√°s complejo
    que gestionar dashboard (/admin = 1), cuando es al rev√©s
  - Mapeo literal sin significado arquitect√≥nico
```

### üìä Resultado

**Impacto:**
- ‚úÖ N√öMERO indica complejidad real (1 simple, 4 complejo)
- ‚úÖ Predecible sin mirar URL (puerta/t√∫nel/control/proyecci√≥n)
- ‚úÖ Escalable (agregar /admin/deep/nested/route NO rompe l√≥gica)

**Lecci√≥n aprendida:**
> **"N√öMERO debe reflejar FUNCI√ìN (qu√© hace), no FORMA (c√≥mo se ve URL)."**

---

## DECISI√ìN 3: SUB-NODOS para Tabs (NO Nodos Separados)

### ‚úÖ Decisi√≥n Tomada

```yaml
SUB-NODO: Misma URL, diferentes secciones (tabs/accordion)
NODO: URLs diferentes

Notaci√≥n:
  NODO: 1B (/mi-dashboard)
  SUB-NODOS:
    - 1B.Perfil (tab perfil)
    - 1B.Cotizaciones (tab cotizaciones)
    - 1B.Mensajes (tab mensajes)
    - 1B.Notificaciones (tab notificaciones)

Implementaci√≥n:
  - URL NO cambia (/mi-dashboard)
  - React state cambia tab activo
  - Firestore queries diferentes por tab
```

### ü§î Razonamiento

**Por qu√© SUB-NODOS:**

1. **Dashboard cliente tiene 4 tabs en MISMA URL:**
   ```typescript
   // src/app/mi-dashboard/page.tsx
   const [activeTab, setActiveTab] = useState('perfil');

   // URL: /mi-dashboard (NO cambia)
   // Vista: Cambia seg√∫n activeTab
   ```

2. **No son nodos separados:**
   - NO requieren navegaci√≥n (router.push)
   - NO tienen URL propia
   - Comparten layout y contexto
   - React state local maneja cambio

3. **Documentar como nodos separados inflar√≠a mapa:**
   ```yaml
   Si fueran nodos separados (MAL):
     1B1: /mi-dashboard (perfil)
     1B2: /mi-dashboard (cotizaciones)
     1B3: /mi-dashboard (mensajes)
     1B4: /mi-dashboard (notificaciones)

   Problema: 4 nodos con MISMA URL (confuso)
   ```

4. **SUB-NODO captura realidad:**
   ```yaml
   Notaci√≥n (BIEN):
     1B: /mi-dashboard (nodo base)
       ‚îú‚îÄ‚îÄ 1B.Perfil (tab)
       ‚îú‚îÄ‚îÄ 1B.Cotizaciones (tab)
       ‚îú‚îÄ‚îÄ 1B.Mensajes (tab)
       ‚îî‚îÄ‚îÄ 1B.Notificaciones (tab)

   Ventaja: Claro que es 1 nodo con 4 secciones
   ```

### ‚ùå Alternativa Rechazada

```yaml
Opci√≥n rechazada A: Nodos separados por tab

Ejemplo:
  2B1: Tab Perfil
  2B2: Tab Cotizaciones
  2B3: Tab Mensajes
  2B4: Tab Notificaciones

Problemas:
  - URLs iguales (/mi-dashboard) pero nodos diferentes (confuso)
  - Mapa inflado (34 SUB-NODOS ‚Üí 34 nodos separados)
  - NO refleja c√≥digo real (tabs son state, no routing)

---

Opci√≥n rechazada B: Ignorar tabs, documentar solo dashboard

Ejemplo:
  1B: /mi-dashboard (sin mencionar tabs)

Problemas:
  - Pierde detalle importante (qu√© hay EN dashboard)
  - Claude no sabr√≠a que hay 4 secciones diferentes
  - Documentaci√≥n superficial vs profunda
```

### üìä Resultado

**Impacto:**
- ‚úÖ Mapa claro (1 nodo base + 4 SUB-NODOS vs 5 nodos separados)
- ‚úÖ Refleja c√≥digo real (React state, no routing)
- ‚úÖ Extensible (agregar tab = agregar SUB-NODO, no nodo)

**Estad√≠sticas:**
```yaml
Sin SUB-NODOS: 30 nodos separados
Con SUB-NODOS: 30 nodos + 4 SUB-NODOS (mapa 12% m√°s compacto)
```

**Lecci√≥n aprendida:**
> **"SUB-NODOS = misma URL, NODOS = URLs diferentes. Pregunta: ¬øCambia URL? NO ‚Üí SUB-NODO."**

---

## DECISI√ìN 4: Admin Mobile vs Desktop Separados

### ‚úÖ Decisi√≥n Tomada

```yaml
Documentar Admin en 2 versiones:

Admin Mobile (iPhone Jonathan):
  - 28 URLs accesibles
  - 2 URLs mobile-optimized:
    - /admin/cotizaciones (touch 44px, cards, llamar/WhatsApp)
    - /admin/clientes (VIP system, integraci√≥n Maps)
  - Uso: 90% del tiempo (terreno)

Admin Desktop (Computador Oficina):
  - 34 URLs accesibles
  - 6 URLs desktop-only:
    - /admin (dashboard widgets)
    - /admin/servicios (CRUD)
    - /admin/materiales (CRUD)
    - /admin/calendario (eventos)
    - /admin/reportes (CSV/PDF export)
    - /admin/configuracion (settings)
  - Uso: 10% del tiempo (oficina)
```

### ü§î Razonamiento

**Por qu√© separar Mobile vs Desktop:**

1. **Jonathan usa iPhone 90% del tiempo:**
   - Trabaja en terreno (instalaciones, visitas)
   - Necesita gestionar cotizaciones DESDE obra
   - Desktop solo en oficina (poco frecuente)

2. **URLs mobile-optimized son DIFERENTES:**
   ```yaml
   /admin/cotizaciones (mobile):
     - Touch targets ‚â• 44px (Apple HIG)
     - Cards (NO tabla)
     - Botones: Llamar, WhatsApp (1 tap)
     - Marcar "Contactado" (1 tap)
     - Sin scroll horizontal

   /admin/cotizaciones (desktop):
     - Tabla con m√∫ltiples columnas
     - Filtros sidebar
     - Selecci√≥n m√∫ltiple
     - Exportar CSV/PDF
   ```

3. **Diferentes casos de uso:**
   ```yaml
   Mobile (terreno):
     - Ver nuevas cotizaciones
     - Llamar cliente directo
     - Marcar como contactado
     - Triage r√°pido

   Desktop (oficina):
     - Editar contenido web (servicios, materiales)
     - Calendario detallado
     - Reportes y analytics
     - Configuraci√≥n sistema
   ```

### ‚ùå Alternativa Rechazada

```yaml
Opci√≥n rechazada: Documentar Admin como 1 solo rol

Ejemplo:
  Admin (34 URLs totales, sin diferenciar mobile/desktop)

Problemas:
  - Oculta realidad: Jonathan NO usa desktop frecuentemente
  - Skills mobile-specific perdidas (touch targets, llamar/WhatsApp)
  - Documentaci√≥n gen√©rica vs especializada
  - Claude no sabr√≠a optimizar para iPhone (contexto cr√≠tico)

Resultado MAL:
  - "Revisa admin cotizaciones" ‚Üí ¬øCu√°l? ¬øMobile o desktop?
  - Recomendaciones desktop cuando Jonathan usa mobile
  - P√©rdida de contexto de uso real
```

### üìä Resultado

**Impacto:**
- ‚úÖ Documentaci√≥n refleja uso REAL (90% mobile, 10% desktop)
- ‚úÖ Skills especializadas por dispositivo
- ‚úÖ Claude optimiza seg√∫n contexto (mobile-first para Jonathan)

**Estad√≠sticas:**
```yaml
Admin Mobile: 28 URLs (18 Guest + 8 Cliente + 2 Admin Mobile)
Admin Desktop: 34 URLs (28 Mobile + 6 Desktop-only)

Skills creadas:
  - ROL_ADMIN_MOBILE_COTIZACIONES.md
  - ROL_ADMIN_MOBILE_CLIENTES.md
  - ROL_ADMIN_DESKTOP_DASHBOARD.md
  - ROL_ADMIN_DESKTOP_SERVICIOS.md
  - ROL_ADMIN_DESKTOP_MATERIALES.md
  - ROL_ADMIN_DESKTOP_CALENDARIO.md
  - ROL_ADMIN_DESKTOP_REPORTES.md
  - ROL_ADMIN_DESKTOP_CONFIGURACION.md
```

**Lecci√≥n aprendida:**
> **"Si device determina UX/funcionalidad, documentar separado. Contexto de uso > categor√≠a gen√©rica."**

---

## DECISI√ìN 5: Transacciones WiFi Asim√©tricas

### ‚úÖ Decisi√≥n Tomada

```yaml
Patr√≥n: C ‚Üí [A ‚áÑ C] (asim√©trico bidireccional)

Flujo real:
  1. Cliente crea cotizaci√≥n (C ‚Üí Firestore)
  2. Admin recibe notificaci√≥n (Firestore ‚Üí A)
  3. Admin responde m√∫ltiple veces:
     - Cambia estado NUEVO ‚Üí CONTACTADO (A ‚Üí Firestore ‚Üí C)
     - Asigna precio (A ‚Üí Firestore ‚Üí C)
     - Env√≠a mensaje (A ‚Üí Firestore ‚Üí C)
     - Cambia estado CONTACTADO ‚Üí COTIZADO (A ‚Üí Firestore ‚Üí C)
  4. Cliente ve cambios en <1 segundo (real-time)

Notaci√≥n: C ‚Üí [A ‚áÑ C] asim√©trico
```

### ü§î Razonamiento

**Por qu√© asim√©trico:**

1. **Cliente env√≠a 1 vez, Admin responde m√∫ltiple:**
   ```yaml
   Cliente (1 acci√≥n):
     - Crea cotizaci√≥n
     - Espera respuesta

   Admin (N acciones):
     - Revisa cotizaci√≥n
     - Llama cliente
     - Cambia estado (m√∫ltiples veces)
     - Asigna precio
     - Env√≠a mensajes
   ```

2. **NO es sim√©trico bidireccional:**
   ```yaml
   Sim√©trico ser√≠a:
     A ‚áÑ B (ambos env√≠an/reciben con igual frecuencia)

   Real es:
     C ‚Üí [A ‚áÑ C] (Cliente inicia, Admin responde N veces)
   ```

3. **Mecanismo real-time (Firebase onSnapshot):**
   ```typescript
   // Cliente escucha SOLO SUS cotizaciones
   onSnapshot(
     query(collection(db, 'quotes'), where('clientId', '==', userId)),
     (snapshot) => { /* Actualiza UI en <1s */ }
   );

   // Admin escucha TODAS las cotizaciones
   onSnapshot(
     collection(db, 'quotes'),
     (snapshot) => { /* Actualiza dashboard */ }
   );
   ```

### ‚ùå Alternativa Rechazada

```yaml
Opci√≥n rechazada: Documentar como sim√©trico (A ‚áÑ C)

Problemas:
  - Implica que ambos env√≠an/reciben con igual frecuencia (FALSO)
  - Cliente env√≠a 1 vez, Admin responde 5-10 veces
  - Notaci√≥n pierde asimetr√≠a real del flujo

Hubiera resultado en:
  - Documentaci√≥n imprecisa
  - Expectativas incorrectas (Cliente espera poder responder m√∫ltiple)
  - Claude no captura patr√≥n de uso real
```

### üìä Resultado

**Impacto:**
- ‚úÖ Notaci√≥n precisa (C ‚Üí [A ‚áÑ C] refleja asimetr√≠a)
- ‚úÖ Claude entiende que Admin es "respondedor activo"
- ‚úÖ Documentaci√≥n alineada con c√≥digo (onSnapshot listeners)

**Ejemplo conversaci√≥n:**
```yaml
Usuario: "¬øC√≥mo funciona el flujo de cotizaciones?"
Claude: "Es asim√©trico: Cliente crea 1 vez (C ‚Üí),
         luego Admin responde m√∫ltiple ([A ‚áÑ C]).
         Real-time v√≠a Firebase onSnapshot."
```

**Lecci√≥n aprendida:**
> **"Transacciones bidireccionales NO siempre son sim√©tricas. Documentar patr√≥n REAL de frecuencia."**

---

## DECISI√ìN 6: LETRA A y B seg√∫n Contexto (NO Fijo)

### ‚úÖ Decisi√≥n Tomada

```yaml
LETRA = Contexto de uso (flexible)

Cliente:
  LETRA A (acci√≥n): Crear cotizaciones
  LETRA B (browse): Dashboard (navegar tabs)

Admin:
  LETRA A (control): Dashboard, CRUD
  LETRA B (browse): (No usado actualmente)

Definici√≥n:
  A = Admin/Control/Dashboard (gesti√≥n activa)
  B = Browse/Lista/P√∫blico (navegaci√≥n, lectura)
```

### ü§î Razonamiento

**Por qu√© contexto flexible:**

1. **Cliente usa AMBAS letras:**
   ```yaml
   1A: /cotizacion (ACCI√ìN: crear)
   1B: /mi-dashboard (BROWSE: navegar tabs)

   Raz√≥n: Cliente tiene 2 contextos diferentes
   ```

2. **NO es "A = Admin, B = Cliente":**
   ```yaml
   Si fuera rol fijo:
     LETRA A = solo Admin
     LETRA B = solo Cliente

   Problema: Cliente tiene acciones (crear cotizaci√≥n = A)
            pero tambi√©n browsea (dashboard = B)
   ```

3. **Es contexto de USO, no categor√≠a de usuario:**
   ```yaml
   Pregunta: ¬øQu√© HACE el usuario en este nodo?

   Crear/Modificar/Gestionar ‚Üí LETRA A
   Leer/Navegar/Explorar ‚Üí LETRA B
   Auditar/Historial ‚Üí LETRA C (futuro)
   ```

### ‚ùå Alternativa Rechazada

```yaml
Opci√≥n rechazada: LETRA = Rol fijo

Ejemplo:
  A = Admin (solo Jonathan)
  B = Cliente (solo clientes autenticados)
  G = Guest (no autenticado)

Problemas:
  - Cliente crea cotizaciones (¬øes A o B?)
  - Admin navega tambi√©n (¬øes B aunque sea admin?)
  - Confunde ROL con ACCI√ìN

Hubiera resultado en:
  - Mapeo confuso (Cliente tiene nodos A y B, incoherente)
  - P√©rdida de significado de LETRA (rol ya est√° en CAPA 0)
  - Redundancia innecesaria
```

### üìä Resultado

**Impacto:**
- ‚úÖ LETRA independiente de rol (m√°s flexible)
- ‚úÖ Contexto de uso claro (acci√≥n vs browse)
- ‚úÖ Escalable (agregar LETRA C = auditor√≠a sin conflicto)

**Ejemplo mapeo:**
```yaml
Cliente:
  1A: /cotizacion (ACCI√ìN)
  2A1: /cotizacion/rapida (ACCI√ìN continuada)
  1B: /mi-dashboard (BROWSE)

Admin:
  3A: /admin (CONTROL dashboard)
  2A: /admin/servicios (ACCI√ìN CRUD)
```

**Lecci√≥n aprendida:**
> **"LETRA = contexto de USO (qu√© hace), NO categor√≠a de USUARIO (qui√©n es). Independiente de rol."**

---

## DECISI√ìN 7: URLs P√∫blicas = TODOS los Roles

### ‚úÖ Decisi√≥n Tomada

```yaml
Concepto: Sitio web CON CRM (NO app interna)

Guest: 18 URLs p√∫blicas
Cliente: HEREDA 18 p√∫blicas + 8 adicionales = 26 URLs
Admin Mobile: HEREDA 26 Cliente + 2 adicionales = 28 URLs
Admin Desktop: HEREDA 28 Mobile + 6 adicionales = 34 URLs

Raz√≥n: Admin puede navegar sitio web p√∫blico TAMBI√âN
```

### ü§î Razonamiento

**Por qu√© herencia acumulativa:**

1. **Es un sitio web p√∫blico CON CRM:**
   - NO es herramienta interna (tipo Jira, Notion)
   - P√°gina web p√∫blica (/, /servicios, /materiales) accesible por TODOS
   - Admin tambi√©n puede navegar sitio p√∫blico

2. **Realidad de uso:**
   ```yaml
   Jonathan (Admin) puede:
     - Ver homepage (/)
     - Ver servicios p√∫blicos (/servicios)
     - Ver materiales p√∫blicos (/materiales)
     - Gestionar cotizaciones (/admin/cotizaciones)
     - Editar contenido (/admin/servicios)

   No tiene sentido BLOQUEAR URLs p√∫blicas a Admin
   ```

3. **Herencia l√≥gica:**
   ```yaml
   Guest (18) = Base p√∫blica
   Cliente (26) = Base + funcionalidad autenticado
   Admin (28-34) = Todo Cliente + panel admin

   NO es:
   Guest (18) = P√∫blico
   Admin (X) = Solo admin (sin p√∫blico) ‚Üê INCORRECTO
   ```

### ‚ùå Alternativa Rechazada

```yaml
Opci√≥n rechazada: Roles separados sin herencia

Ejemplo:
  Guest: 18 URLs (solo p√∫blico)
  Cliente: 8 URLs (solo cliente, SIN p√∫blico)
  Admin: 8 URLs (solo admin, SIN p√∫blico ni cliente)

Problemas:
  - Admin NO puede ver homepage (absurdo)
  - Cliente NO puede ver /servicios (il√≥gico)
  - Documentaci√≥n no refleja realidad

Hubiera resultado en:
  - Mapeo incorrecto de permisos
  - Middleware bloqueando URLs p√∫blicas a roles superiores
  - Confusi√≥n total
```

### üìä Resultado

**Impacto:**
- ‚úÖ Documentaci√≥n refleja realidad (sitio web p√∫blico + CRM)
- ‚úÖ Herencia clara (cada rol incluye anterior)
- ‚úÖ Middleware correcto (p√∫blicas NO validan auth)

**Estad√≠sticas:**
```yaml
Guest: 18 URLs
Cliente: 18 + 8 = 26 URLs
Admin Mobile: 18 + 8 + 2 = 28 URLs
Admin Desktop: 18 + 8 + 2 + 6 = 34 URLs
```

**Lecci√≥n aprendida:**
> **"En sitio web CON CRM, roles superiores HEREDAN URLs p√∫blicas. NO bloquear base a usuarios avanzados."**

---

## üìä TABLA RESUMEN DE DECISIONES

| # | Decisi√≥n | Template Gen√©rico | Soluciones D√≠az | Impacto |
|---|----------|-------------------|-----------------|---------|
| 1 | CAPA 0 | Guardian de Planes | Sistema de Roles (G/C/A/SA) | +100% alineaci√≥n con c√≥digo real |
| 2 | N√öMERO | Niveles de URL (f√≠sico) | Profundidad funcional (1=puerta, 2=t√∫nel) | +80% claridad arquitect√≥nica |
| 3 | SUB-NODOS | No diferenciaba claramente | Tabs = SUB-NODOS (misma URL) | Mapa 12% m√°s compacto, +90% precisi√≥n |
| 4 | Admin | 1 rol gen√©rico | Mobile (90%) vs Desktop (10%) | +100% optimizaci√≥n por dispositivo |
| 5 | Transacciones | Sim√©trico (A ‚áÑ B) | Asim√©trico (C ‚Üí [A ‚áÑ C]) | +100% precisi√≥n flujo real |
| 6 | LETRA | Branch fijo | Contexto uso (acci√≥n/browse) | +60% flexibilidad, -30% confusi√≥n |
| 7 | URLs P√∫blicas | No especificado | Heredadas por todos roles | +100% reflejo realidad sitio web |

---

## üéì LECCIONES GENERALES

### 1. Template es GU√çA, no BIBLIA
```yaml
Template gen√©rico:
  ‚úÖ Provee estructura base
  ‚úÖ Conceptos fundamentales (N√öMERO+LETRA+CAPA)

Pero:
  ‚ö†Ô∏è  NO es copy-paste directo
  ‚ö†Ô∏è  Adaptar a TU contexto espec√≠fico
  ‚ö†Ô∏è  Algunas decisiones del template NO aplican
```

### 2. Documentaci√≥n debe reflejar C√ìDIGO real
```yaml
Pregunta clave:
  "¬øEsto documenta c√≥mo FUNCIONA o c√≥mo DEBER√çA funcionar?"

Soluciones D√≠az:
  ‚úÖ CAPA 0 = Roles (porque middleware valida `userRole`)
  ‚úÖ Mobile vs Desktop (porque Jonathan usa iPhone 90%)
  ‚úÖ Asim√©trico (porque Cliente 1 vez, Admin N veces)

Resultado:
  Claude Code entiende arquitectura REAL, no te√≥rica
```

### 3. Contexto de uso > Categor√≠as abstractas
```yaml
MAL:
  LETRA A = Admin (categor√≠a)
  LETRA B = Cliente (categor√≠a)

BIEN:
  LETRA A = Acci√≥n/Control (contexto)
  LETRA B = Browse/Leer (contexto)

Raz√≥n:
  Cliente puede hacer acciones (A) y browsear (B)
  Contexto de uso es m√°s flexible que categor√≠a fija
```

### 4. Pregunta "¬øPOR QU√â?" antes de aplicar
```yaml
Template dice: "N√öMERO = niveles de URL"

NO aplicar ciegamente, preguntar:
  ¬øPor qu√© niveles de URL?
  ¬øQu√© problema resuelve?
  ¬øAplica a MI caso?

En Soluciones D√≠az:
  Niveles f√≠sicos NO reflejaban complejidad
  ‚Üí Cambiar a funcional (puerta/t√∫nel/control)
  ‚Üí Resultado: +80% claridad
```

### 5. Iterar y validar con uso real
```yaml
Primera iteraci√≥n:
  - Mapa inicial con 30 nodos
  - LETRA fija por rol (confuso)

Segunda iteraci√≥n (despu√©s de usar 1 semana):
  - LETRA por contexto (mejor)
  - SUB-NODOS identificados (mapa m√°s claro)
  - Admin Mobile vs Desktop (reflejo real)

Lecci√≥n:
  Sistema evoluciona con uso
  Primera versi√≥n NO ser√° perfecta
  Validar con conversaciones reales con Claude
```

---

## üîÆ DECISIONES FUTURAS (Pendientes)

### 1. LETRA C para Auditor√≠a/History

```yaml
Estado actual: LETRA C no usada

Propuesta futura:
  LETRA C = History/Auditor√≠a
  - Logs de cambios
  - Historial de cotizaciones
  - Auditor√≠a de acciones admin

Por implementar cuando se agreguen features de compliance
```

### 2. N√öMERO 5 para Integraciones

```yaml
Estado actual: N√öMERO 1-4 usados

Propuesta futura:
  N√öMERO 5 = Integraciones externas
  - APIs terceros
  - Webhooks
  - Sincronizaci√≥n externa

Por implementar cuando se integren sistemas externos
```

### 3. SuperAdmin Separado en Mapa

```yaml
Estado actual: SuperAdmin documentado en ROLES_COMPLETO.md

Propuesta futura:
  Crear skill espec√≠fica para nodos SuperAdmin
  - /superadmin/* (DevTools)
  - Debugging avanzado
  - Deploy control

Por implementar cuando se ampl√≠en herramientas dev
```

---

## üìù CONTRIBUIR MEJORAS

**¬øEncontraste mejor decisi√≥n?**

1. Abre Issue en GitHub
2. Explica:
   - Decisi√≥n actual
   - Tu propuesta
   - Por qu√© es mejor
   - Evidencia (c√≥digo, uso real)
3. Discute con comunidad
4. Implementa mejora
5. Actualiza DECISIONS-LOG.md

---

**Creado:** 2025-10-26
**Autor:** Patricio D√≠az + Claude
**Versi√≥n:** 1.0.0
**√öltima actualizaci√≥n:** 2025-10-26

üåå **"Decisiones arquitect√≥nicas documentadas = contexto para IA + humanos futuros"**
